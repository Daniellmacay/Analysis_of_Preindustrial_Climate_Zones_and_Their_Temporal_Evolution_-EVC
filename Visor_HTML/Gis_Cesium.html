<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Gis_Cesium (EVC) - Viewer</title>

  <!-- Cesium (mantengo versión 1.120 similar al original) -->
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
  <link href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css" rel="stylesheet" />

  <!-- D3 y Plotly -->
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>

  <style>
    html, body, #cesiumContainer {
      width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden;
      font-family: sans-serif; background-color: #000;
    }
    .control-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(40,40,40,0.92);
      padding: 15px;
      border-radius: 8px;
      color: white;
      max-height: 95vh;
      overflow-y: auto;
      z-index: 2000;
      width: 320px;
      box-shadow: 0 6px 18px rgba(0,0,0,0.5);
    }
    #svdPlotContainer {
      position: absolute;
      right: 10px;
      top: 10px;
      z-index: 2000;
      width: 340px;
      display: none;
      background: rgba(20,20,20,0.9);
      padding: 12px;
      border-radius: 8px;
      color: white;
      max-height: 95vh;
      overflow-y: auto;
    }
    #svdPlotContainer.maximized {
      width: 95vw;
      height: 95vh;
      top: 2.5vh;
      left: 2.5vw;
      right: auto;
      z-index: 4000;
    }
    label { font-weight: bold; display:block; margin-top:8px; }
    select, input[type="file"], input[type="range"], button { width: 100%; margin-top:6px; box-sizing: border-box; }
    .plot-container { margin-top:10px; background: #fff; border-radius:6px; padding:8px; color: #000; }
    .plot-container h4 { margin:0 0 6px 0; }
    .toggle-plot-size-btn { background:none; border:none; color:white; font-size:18px; cursor:pointer; }
    #plot-container { margin-top:12px; background:#fff; border-radius:6px; padding:6px; min-height:140px; }
  </style>
</head>
<body>
  <div id="cesiumContainer"></div>

  <div class="control-panel" id="controls">
    <h3 style="margin:0 0 8px 0;">Controles EVC (Gis_Cesium)</h3>

    <label for="csvFile">1. Cargar Archivo Principal (.csv)</label>
    <input type="file" id="csvFile" accept=".csv">

    <div id="networkFileControls" style="display:none;">
      <label for="edgesFile">Cargar Aristas (.csv)</label>
      <input type="file" id="edgesFile" accept=".csv">
    </div>

    <label for="visualization-select">2. Seleccionar Visualización:</label>
    <select id="visualization-select">
      <option value="none">-- Cargar un archivo --</option>
      <option value="pca" style="display:none;">Temperatura (SVD)</option>
      <option value="som" style="display:none;">Clústeres (SOM)</option>
      <option value="network" style="display:none;">Análisis de Red</option>
    </select>

    <div id="pcaControls" style="display:none;">
      <label for="pcaModeSelector">Modo de Visualización:</label>
      <select id="pcaModeSelector">
        <option value="decades">Valores por Década</option>
        <option value="spatial_modes">Modos Espaciales (Patrones)</option>
      </select>

      <div id="decadesView">
        <label for="decadeSelector">Periodo (década):</label>
        <select id="decadeSelector"></select>

        <label for="amplitudeSlider">Amplitud de Visualización: <span id="amplitudeValue">0.00</span></label>
        <input id="amplitudeSlider" type="range" min="0" max="1" step="0.01" value="0">
      </div>

      <div id="spatialModesView" style="display:none;">
        <label>Tipo de Análisis Espacial:</label>
        <input type="radio" id="modeGlobal" name="spatialModeType" value="global" checked>
        <label for="modeGlobal" style="display:inline;font-weight:normal;">Visión Global</label><br>
        <input type="radio" id="modeDecade" name="spatialModeType" value="decade">
        <label for="modeDecade" style="display:inline;font-weight:normal;">Análisis por Década</label>

        <div id="decadeSpecificControls" style="display:none;">
          <label for="spatialModeDecadeSelector">Seleccionar Década:</label>
          <select id="spatialModeDecadeSelector"></select>
        </div>

        <label for="spatialModeSelector">Seleccionar Modo (1-100):</label>
        <select id="spatialModeSelector"></select>
      </div>

      <button id="toggleSvdPlotBtn" style="margin-top:10px;">Mostrar/Ocultar Gráficas</button>
    </div>

    <div id="somControls" style="display:none;">
      <label for="somClusterSelector">Filtrar por Grupo SOM:</label>
      <select id="somClusterSelector"></select>
    </div>

    <hr style="border-color:#444;margin:12px 0;">

    <label for="geojsonFile">3. Cargar Regiones (GeoJSON)</label>
    <input type="file" id="geojsonFile" accept=".geojson,.json">
    <button id="toggleBaseLayerBtn" style="margin-top:8px;">Apagar/Encender Mapa Base</button>

    <div id="plot-container" class="plot-container" style="display:block;"></div>
  </div>

  <div id="svdPlotContainer">
    <div id="logLogPlot" class="plot-container">
      <h4 id="plotTitle">Scree Plot (Log-Log)
        <button id="togglePlotSizeBtn" class="toggle-plot-size-btn" title="Maximizar / Minimizar Gráfica">&#9974;</button>
      </h4>
      <div style="font-size:12px;margin-bottom:6px;">
        <label style="font-weight:normal;"><input type="radio" name="plotViewType" value="single" checked> Vista por Década</label>
        <label style="font-weight:normal;margin-left:8px;"><input type="radio" name="plotViewType" value="all"> Vista Comparativa (Todas)</label>
      </div>
      <div id="graphDecadeSelectorContainer">
        <label for="graphDecadeSelector" style="font-weight:normal;font-size:12px;">Seleccionar Década:</label>
        <select id="graphDecadeSelector"></select>
      </div>
      <svg id="logLogPlotSvg" style="width:100%;height:200px;"></svg>
    </div>

    <div id="temporalModePlot" class="plot-container" style="display:none;">
      <h4>Perfil Temporal del Modo</h4>
      <svg id="temporalModePlotSvg" style="width:100%;height:150px;"></svg>
    </div>
  </div>

  <script>
    // === TOKEN (insertado por ti) ===
    Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyNDE3NjFjMy03ZmNlLTRjNmItOGYzMC05Y2I1YmY2ZGI3NjYiLCJpZCI6MzMwMzc2LCJpYXQiOjE3NTY3NTA4MjV9.LcZwospuKIuQxSopfU9pk2DfHci5oN1HaYNptFpMwQk';

    // === Inicializar Cesium Viewer ===
    const viewer = new Cesium.Viewer('cesiumContainer', {
      terrainProvider: Cesium.Terrain.fromWorldTerrain(),
      infoBox: false, selectionIndicator: false, sceneModePicker: true
    });
    viewer.scene.backgroundColor = Cesium.Color.BLACK;

    // === Variables globales ===
    let mainData = [];
    let tempColumns = [];
    let pcColumns = [];
    let somColumn = '';
    let svdDataByDecade = {};
    let maxSomCluster = 1;
    let networkEdges = [];
    let geojsonLayer = null;
    const baseLayer = viewer.imageryLayers.get(0);

    // Escalas
    const pcaColorScale = d3.scaleLinear().domain([-1, 0, 1]).range(["blue", "rgba(255,255,255,0.1)", "red"]);

    function safeSomColor(clusterId) {
      const idNum = Number(clusterId);
      if (!isFinite(idNum) || maxSomCluster <= 1) {
        return Cesium.Color.fromCssColorString("#888888");
      } else {
        const h = (idNum - 1) / (maxSomCluster - 1);
        return Cesium.Color.fromHsl(h, 0.85, 0.55);
      }
    }

    // === LECTURA DE CSV -- ahora vía input público ===
    document.getElementById('csvFile').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const parsed = d3.csvParse(e.target.result, d3.autoType);
          if (!parsed || parsed.length === 0) { alert("CSV vacío o inválido."); return; }
          // Validar lon/lat
          if (!Object.keys(parsed[0]).includes('lon') || !Object.keys(parsed[0]).includes('lat')) {
            alert("El CSV debe incluir columnas 'lon' y 'lat'."); return;
          }
          loadData(parsed);
        } catch (err) {
          console.error(err); alert("Error al parsear CSV."); 
        }
      };
      reader.readAsText(file);
    });

    // Opcional: carga de aristas para redes
    document.getElementById('edgesFile').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          networkEdges = d3.csvParse(e.target.result, d3.autoType);
          if (document.getElementById('visualization-select').value === 'network') updateVisualization();
        } catch (err) {
          console.error(err); alert("Error cargando aristas CSV.");
        }
      };
      reader.readAsText(file);
    });

    // GeoJSON
    document.getElementById('geojsonFile').addEventListener('change', function(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const obj = JSON.parse(e.target.result);
          if (geojsonLayer) viewer.dataSources.remove(geojsonLayer, true);
          Cesium.GeoJsonDataSource.load(obj, {
            stroke: Cesium.Color.YELLOW.withAlpha(0.8), fill: Cesium.Color.YELLOW.withAlpha(0.08), strokeWidth: 2
          }).then(ds => {
            geojsonLayer = ds;
            viewer.dataSources.add(ds);
            viewer.zoomTo(ds);
          }).catch(err => { console.error(err); alert("Error cargando GeoJSON."); });
        } catch (err) { console.error(err); alert("GeoJSON inválido."); }
      };
      reader.readAsText(file);
    });

    // Toggle base layer
    document.getElementById('toggleBaseLayerBtn').addEventListener('click', () => { baseLayer.show = !baseLayer.show; });

    // === CARGAR Y PREPARAR DATOS ===
    function loadData(parsedData) {
      mainData = parsedData;
      // Identificar columnas
      const cols = Object.keys(mainData[0]);
      tempColumns = cols.filter(c => c.startsWith('temp_')).sort();
      pcColumns = cols.filter(c => c.startsWith('PC_')).sort();
      somColumn = cols.find(c => c === 'som_cluster');

      // Actualizar UI
      document.getElementById('controls').querySelectorAll('#controls > p').forEach(n => n.remove()); // limpiar mensajes
      document.getElementById('controls-content')?.remove?.(); // en caso existiera; no queremos duplicar
      // Mostrar secciones relevantes
      const vizSelect = document.getElementById('visualization-select');
      // ocultar opciones previas (excepto none)
      Array.from(vizSelect.options).forEach(opt => { if (opt.value !== 'none') opt.style.display = 'none'; });

      if (tempColumns.length > 0) {
        document.querySelector('option[value="pca"]').style.display = 'block';
        // poblar select de décadas
        const decSelector = document.getElementById('decadeSelector');
        const spatialDecSelector = document.getElementById('spatialModeDecadeSelector');
        const graphDecSelector = document.getElementById('graphDecadeSelector');
        const decadeOptions = tempColumns.map(c => `<option value="${c}">${c.replace('temp_','')}</option>`).join('');
        decSelector.innerHTML = decadeOptions;
        spatialDecSelector.innerHTML = decadeOptions;
        graphDecSelector.innerHTML = decadeOptions;
      }
      if (pcColumns.length > 0) {
        // Si tienes patrones PCA exportados como PC_*, los incluyo en el select principal (como patrones)
        pcColumns.forEach(pc => {
          const opt = document.createElement('option');
          opt.value = pc;
          opt.text = `Patrón PCA (${pc})`;
          opt.style.display = 'block';
          vizSelect.appendChild(opt);
        });
      }
      if (somColumn) {
        document.querySelector('option[value="som"]').style.display = 'block';
        const clusters = [...new Set(mainData.map(d => d[somColumn]))].filter(x => x !== undefined && x !== null).sort((a,b)=>a-b);
        maxSomCluster = clusters.length || 1;
        const sel = document.getElementById('somClusterSelector');
        sel.innerHTML = '<option value="all">-- Todos los Grupos --</option>' + clusters.map(c=>`<option value="${c}">Grupo ${c}</option>`).join('');
      }
      // show network option if id/lat exist
      if (cols.includes('id') && cols.includes('lat')) document.querySelector('option[value="network"]').style.display = 'block';

      // Inicializar SVD simulation or load if provided
      performSVDAnalysis(mainData);

      // Mostrar controles relevantes
      document.getElementById('pcaControls').style.display = (tempColumns.length>0) ? 'block' : 'none';
      document.getElementById('somControls').style.display = (somColumn ? 'block' : 'none');

      // Set defaults in UI
      document.getElementById('visualization-select').value = tempColumns.length>0 ? 'pca' : (somColumn ? 'som':'none');
      setupUIListeners(); // attach listeners (idempotent)
      // Render initial points
      updateVisualization();
    }

    // === VISUALIZACIONES: PCA / SOM / Network ===
    function updateVisualization() {
      viewer.entities.removeAll();
      const vizType = document.getElementById('visualization-select').value;
      if (!mainData.length || vizType === 'none') return;
      if (vizType === 'pca') visualizePCA();
      if (vizType === 'som') visualizeSOM();
      if (vizType === 'network') visualizeNetwork();
    }

    function visualizePCA() {
      const mode = document.getElementById('pcaModeSelector').value;
      const maxHeight = 400000.0;
      if (mode === 'decades') {
        const selectedDecade = document.getElementById('decadeSelector').value;
        if (!selectedDecade) return;
        const amplitude = parseFloat(document.getElementById('amplitudeSlider').value);
        const maxAbsValue = d3.max(mainData, d => Math.abs(d[selectedDecade] || 0)) || 1.0;
        mainData.forEach((d,i) => {
          const value = d[selectedDecade] || 0;
          if (Math.abs(value) < (amplitude * maxAbsValue)) return;
          const normalized = Math.max(-1, Math.min(1, value / maxAbsValue));
          const colorStr = pcaColorScale(normalized);
          const color = Cesium.Color.fromCssColorString(colorStr);
          const height = Math.abs(normalized * maxHeight) + 1000;
          viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(d.lon, d.lat),
            box: { dimensions: new Cesium.Cartesian3(80000.0, 80000.0, height), material: color },
            properties: { originalIndex: i }
          });
        });
      } else if (mode === 'spatial_modes') {
        const analysisType = document.querySelector('input[name="spatialModeType"]:checked').value;
        const selectedModeIndex = parseInt(document.getElementById('spatialModeSelector').value) - 1;
        let spatialModeVector;
        if (analysisType === 'decade') {
          const selectedDecade = document.getElementById('spatialModeDecadeSelector').value;
          const svdForDecade = svdDataByDecade[selectedDecade];
          if (!svdForDecade || !svdForDecade.U) return;
          spatialModeVector = svdForDecade.U.map(r => r[selectedModeIndex] || 0);
        } else {
          const svdGlobal = svdDataByDecade['global'];
          if (!svdGlobal || !svdGlobal.U) return;
          spatialModeVector = svdGlobal.U.map(r => r[selectedModeIndex] || 0);
        }
        const maxAbs = d3.max(spatialModeVector.map(Math.abs)) || 1.0;
        mainData.forEach((d,i) => {
          const value = spatialModeVector[i] || 0;
          const normalized = value / maxAbs;
          const colorStr = pcaColorScale(normalized);
          const height = Math.abs(normalized * maxHeight) + 1000;
          viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(d.lon, d.lat),
            box: { dimensions: new Cesium.Cartesian3(80000.0, 80000.0, height), material: Cesium.Color.fromCssColorString(colorStr) },
            properties: { originalIndex: i }
          });
        });
      }
    }

    function visualizeSOM() {
      const selectedGroup = document.getElementById('somClusterSelector').value;
      const isFiltered = selectedGroup && selectedGroup !== 'all';
      const dataToShow = isFiltered ? mainData.filter(d => d[somColumn] == selectedGroup) : mainData;
      dataToShow.forEach((d,i) => {
        if (d[somColumn] === undefined || d.som_cluster === null) return;
        const color = safeSomColor(d[somColumn]);
        viewer.entities.add({
          position: Cesium.Cartesian3.fromDegrees(d.lon, d.lat),
          box: { dimensions: new Cesium.Cartesian3(40000.0,40000.0,40000.0), material: color },
          properties: { originalIndex: mainData.indexOf(d) }
        });
      });
      if (isFiltered && dataToShow.length > 0) {
        const avgLon = d3.mean(dataToShow, d => d.lon);
        const avgLat = d3.mean(dataToShow, d => d.lat);
        if (isFinite(avgLon) && isFinite(avgLat)) {
          viewer.camera.flyTo({ destination: Cesium.Cartesian3.fromDegrees(avgLon, avgLat, 1500000), duration: 2.0 });
        }
      }
    }

    function visualizeNetwork() {
      if (networkEdges.length === 0) { alert('Por favor, carga también el archivo de Aristas para visualizar la red.'); return; }
      mainData.forEach((d, i) => {
        const color = d.categoria ? (Cesium.Color.fromCssColorString(d.categoria) || Cesium.Color.ORANGE) : Cesium.Color.ORANGE;
        viewer.entities.add({
          position: Cesium.Cartesian3.fromDegrees(d.lon, d.lat),
          point: { pixelSize: 10, color: color, disableDepthTestDistance: Number.POSITIVE_INFINITY },
          name: `Nodo: ${d.id}`,
          properties: { originalIndex: i }
        });
      });
      networkEdges.forEach(edge => {
        const src = mainData.find(n => n.id === edge.source);
        const tgt = mainData.find(n => n.id === edge.target);
        if (src && tgt) {
          viewer.entities.add({
            polyline: {
              positions: Cesium.Cartesian3.fromDegreesArray([src.lon, src.lat, tgt.lon, tgt.lat]),
              width: 2,
              depthFailMaterial: Cesium.Color.WHITE.withAlpha(0.2),
              material: Cesium.Color.WHITE.withAlpha(0.7)
            },
            properties: { originalIndex: -1 }
          });
        }
      });
    }

    // === SVD / SVD-simulación (si no tienes V/U desde R) ===
    function performSVDAnalysis(data) {
      svdDataByDecade = {};
      const numPoints = data.length;
      const numModes = 100;
      const numDecades = tempColumns.length || 10;

      tempColumns.forEach(decade => {
        const singularValues = Array.from({length: numModes}, (_, i) => 100 * Math.exp(-i / 10) * (0.8 + Math.random() * 0.4));
        svdDataByDecade[decade] = {
          D: singularValues,
          U: Array.from({length: numPoints}, () => Array.from({length: numModes}, () => Math.random() * 2 - 1)),
          V: Array.from({length: numDecades}, () => Array.from({length: numModes}, () => Math.random() * 2 - 1))
        };
      });

      // Simulación global simplificada (3 modos)
      const globalV = [];
      for (let i = 0; i < numDecades; i++) {
        globalV.push([
          (i / (numDecades - 1)) * 2 - 1,
          Math.sin(i * Math.PI * 2 / Math.max(1, numDecades)),
          Math.exp(-Math.pow(i - numDecades/2, 2) / 8) * 2 - 1
        ]);
      }
      svdDataByDecade['global'] = {
        D: [100, 50, 20],
        U: Array.from({length: numPoints}, () => Array.from({length: 3}, () => Math.random() * 2 - 1)),
        V: globalV
      };

      // Dibuja scree plot inicial
      if (tempColumns.length > 0) {
        drawLogLogPlot(tempColumns[0]);
      }
    }

    // === DIBUJOS: Scree plot y perfil temporal (D3) ===
    function drawLogLogPlot(highlightDecade) {
      const plotViewType = document.querySelector('input[name="plotViewType"]:checked').value;
      const decadeToHighlight = highlightDecade || document.getElementById('graphDecadeSelector').value;
      const svg = d3.select("#logLogPlotSvg");
      svg.selectAll("*").remove();
      const containerWidth = parseInt(window.getComputedStyle(document.getElementById('logLogPlot')).width);
      if (isNaN(containerWidth) || containerWidth <= 0) return;
      const margin = {top:10,right:20,bottom:40,left:50};
      const width = containerWidth - margin.left - margin.right;
      const height = 150;

      const allSV = [].concat(...Object.values(svdDataByDecade).map(d=>d.D)).filter(Boolean);
      if (allSV.length === 0) return;
      const x = d3.scaleLog().domain([1,100]).range([0,width]);
      const y = d3.scaleLog().domain(d3.extent(allSV)).range([height,0]);

      const g = svg.attr("width", width+margin.left+margin.right).attr("height", height+margin.top+margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
      g.append("g").attr("transform", `translate(0,${height})`).call(d3.axisBottom(x).ticks(3, ".0s"));
      g.append("g").call(d3.axisLeft(y).ticks(4, ".1s"));

      if (plotViewType === 'single') {
        document.getElementById('plotTitle').textContent = `Scree Plot para Década ${decadeToHighlight.replace('temp_','')}`;
        const dec = svdDataByDecade[decadeToHighlight];
        if (!dec) return;
        const plotData = dec.D.map((v,i)=>({mode:i+1,value:v})).filter(d=>d.value>0);
        const line = d3.line().x(d=>x(d.mode)).y(d=>y(d.value));
        g.append("path").datum(plotData).attr("fill","none").attr("stroke","steelblue").attr("stroke-width",2).attr("d",line);
      } else {
        document.getElementById('plotTitle').textContent = `Scree Plot Comparativo por Década`;
        const colors = d3.scaleOrdinal(d3.schemeTableau10);
        tempColumns.forEach((dec, idx) => {
          const decD = svdDataByDecade[dec].D.map((v,i)=>({mode:i+1,value:v})).filter(d=>d.value>0);
          const line = d3.line().x(d=>x(d.mode)).y(d=>y(d.value));
          g.append("path").datum(decD).attr("fill","none").attr("stroke",colors(idx)).attr("stroke-width", dec===decadeToHighlight?3:1.5).attr("stroke-opacity", dec===decadeToHighlight?1:0.35).attr("d",line);
        });
      }
    }

    function drawTemporalModePlot(modeIndex) {
      if (modeIndex < 0 || !tempColumns.length) return;
      const analysisType = document.querySelector('input[name="spatialModeType"]:checked').value;
      let svdSource = svdDataByDecade['global'];
      if (analysisType === 'decade') {
        const sd = document.getElementById('spatialModeDecadeSelector').value;
        svdSource = svdDataByDecade[sd] || svdSource;
      }
      if (!svdSource || !svdSource.V) return;
      const temporalProfile = svdSource.V.map(row => row[modeIndex] || 0);
      const svg = d3.select("#temporalModePlotSvg");
      svg.selectAll("*").remove();
      const containerWidth = parseInt(window.getComputedStyle(document.getElementById('temporalModePlot')).width);
      if (isNaN(containerWidth) || containerWidth <= 0) return;
      const margin = {top:10,right:20,bottom:40,left:50};
      const width = containerWidth - margin.left - margin.right;
      const height = 120;
      const g = svg.attr("width",width+margin.left+margin.right).attr("height",height+margin.top+margin.bottom).append("g").attr("transform",`translate(${margin.left},${margin.top})`);
      const x = d3.scalePoint().domain(tempColumns.map(d=>d.replace('temp_',''))).range([0,width]);
      const y = d3.scaleLinear().domain(d3.extent(temporalProfile)).range([height,0]);
      g.append("g").attr("transform",`translate(0,${height})`).call(d3.axisBottom(x)).selectAll("text").style("text-anchor","end").attr("dx","-.8em").attr("dy",".15em").attr("transform","rotate(-45)");
      g.append("g").call(d3.axisLeft(y).ticks(5));
      const line = d3.line().x((d,i)=>x(tempColumns[i].replace('temp_',''))).y(d=>y(d));
      g.append("path").datum(temporalProfile).attr("fill","none").attr("stroke","lime").attr("stroke-width",2).attr("d",line);
    }

    // === CLICK EN GLOBO Y GRAFICA (Plotly) ===
    const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
    handler.setInputAction(function(movement) {
      const picked = viewer.scene.pick(movement.position);
      if (Cesium.defined(picked) && Cesium.defined(picked.id)) {
        try {
          const idx = picked.id.properties.originalIndex.getValue();
          if (idx === undefined || idx === null) return;
          const pd = mainData[idx];
          if (!pd) return;
          drawTimeseriesPlot(pd);
        } catch (err) {
          // Fallback: si no hay getValue (antigua API), intentar propiedad directa
          const idx2 = picked.id.properties && picked.id.properties.originalIndex;
          const indexVal = idx2 && (idx2.getValue ? idx2.getValue() : idx2);
          if (indexVal !== undefined && mainData[indexVal]) drawTimeseriesPlot(mainData[indexVal]);
        }
      }
    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

    function drawTimeseriesPlot(pointData) {
      const container = document.getElementById('plot-container');
      // preparar datos
      const plotData = (tempColumns || []).map(col => ({
        decade: parseInt(col.replace('temp_','').replace('s','')),
        temperature: (pointData[col] === '' || pointData[col] === null) ? NaN : pointData[col]
      })).filter(d => d.temperature !== null && !isNaN(d.temperature));

      if (plotData.length === 0) {
        container.innerHTML = "<p style='color:black;padding:8px;'>No hay datos de series de tiempo para este punto.</p>";
        return;
      }

      const trace = {
        x: plotData.map(d=>d.decade),
        y: plotData.map(d=>d.temperature),
        type: 'scatter',
        mode: 'lines+markers',
        line: { color: 'steelblue', width: 2 },
        marker: { size: 6 }
      };
      const layout = {
        title: `Evolución Temp. Cluster ${pointData[somColumn] ?? 'N/A'}`,
        xaxis: { title: 'Década' },
        yaxis: { title: 'Temperatura' },
        margin: { t: 40, r: 12, l: 50, b: 50 },
        paper_bgcolor: '#fff',
        plot_bgcolor: '#fff'
      };
      Plotly.newPlot(container, [trace], layout, {responsive:true});
    }

    // === INTERFAZ: listeners ===
    function setupUIListeners() {
      // visualizacion select
      const viz = document.getElementById('visualization-select');
      viz.addEventListener('change', () => {
        // Mostrar/ocultar controles
        const v = viz.value;
        document.getElementById('pcaControls').style.display = v === 'pca' ? 'block' : 'none';
        document.getElementById('somControls').style.display = v === 'som' ? 'block' : 'none';
        document.getElementById('networkFileControls').style.display = v === 'network' ? 'block' : 'none';
        // Mostrar panel lateral con SVD
        if (v === 'pca') {
          document.getElementById('svdPlotContainer').style.display = 'block';
          drawLogLogPlot(document.getElementById('graphDecadeSelector').value);
        } else {
          document.getElementById('svdPlotContainer').style.display = 'none';
        }
        updateVisualization();
      });

      document.getElementById('pcaModeSelector').addEventListener('change', (e) => {
        const isDecades = e.target.value === 'decades';
        document.getElementById('decadesView').style.display = isDecades ? 'block' : 'none';
        document.getElementById('spatialModesView').style.display = isDecades ? 'none' : 'block';
        document.getElementById('temporalModePlot').style.display = isDecades ? 'none' : 'block';
        if (!isDecades) {
          const m = parseInt(document.getElementById('spatialModeSelector').value)-1;
          drawTemporalModePlot(m);
        }
        updateVisualization();
      });

      document.querySelectorAll('input[name="spatialModeType"]').forEach(r => {
        r.addEventListener('change', (e) => {
          const showDec = e.target.value === 'decade';
          document.getElementById('decadeSpecificControls').style.display = showDec ? 'block' : 'none';
          const modeSel = document.getElementById('spatialModeSelector');
          if (showDec) {
            modeSel.innerHTML = Array.from({length:100},(_,i)=>`<option value="${i+1}">Modo ${i+1}</option>`).join('');
          } else {
            modeSel.innerHTML = Array.from({length:3},(_,i)=>`<option value="${i+1}">Modo ${i+1}</option>`).join('');
          }
          drawTemporalModePlot(modeSel.value-1);
          updateVisualization();
        });
      });

      document.getElementById('graphDecadeSelector').addEventListener('change', (e) => { drawLogLogPlot(e.target.value); });
      document.querySelectorAll('input[name="plotViewType"]').forEach(r => r.addEventListener('change', drawLogLogPlot));
      document.getElementById('spatialModeSelector').addEventListener('input', () => {
        drawTemporalModePlot(document.getElementById('spatialModeSelector').value-1);
        updateVisualization();
      });
      ['decadeSelector','amplitudeSlider','somClusterSelector','spatialModeDecadeSelector'].forEach(id => {
        const el = document.getElementById(id);
        if (el) el.addEventListener('input', updateVisualization);
      });

      document.getElementById('amplitudeSlider').addEventListener('input', (e)=> {
        document.getElementById('amplitudeValue').textContent = parseFloat(e.target.value).toFixed(2);
      });

      document.getElementById('toggleSvdPlotBtn').addEventListener('click', () => {
        const p = document.getElementById('svdPlotContainer');
        p.style.display = (p.style.display === 'none' || p.style.display === '') ? 'block' : 'none';
      });

      document.getElementById('togglePlotSizeBtn').addEventListener('click', () => {
        const p = document.getElementById('svdPlotContainer');
        p.classList.toggle('maximized');
        setTimeout(() => { drawLogLogPlot(); drawTemporalModePlot(document.getElementById('spatialModeSelector').value-1); }, 300);
      });

      // limpiar geojsones
      // ya tienen listener de cambio; añadimos botón para limpiar
      // (botón ya presente en HTML)
    }

    // Llamada inicial para listeners mínimos
    setupUIListeners();

    // === Mensaje final ===
    console.log("Gis_Cesium cargado. Carga un CSV para visualizar (columna lon/lat, columnas temp_*, opcional: som_cluster, PC_...)");
  </script>
</body>
</html>
